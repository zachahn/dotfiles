" vim: syntax=vim

set nocompatible

let mapleader = ' '
let maplocalleader = '\'

if empty(glob('~/.vim/autoload/plug.vim'))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
    \ https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
endif

call plug#begin()
" UI
Plug 'acarapetis/vim-colors-github'
Plug 'itchyny/lightline.vim'
" Navigation
Plug 'zachahn/vim-ack-ag'
Plug 'mileszs/ack.vim'
Plug 'junegunn/fzf', { 'dir': '~/.vim/fzf', 'do': './install --bin' }
Plug 'junegunn/fzf.vim'
Plug 'mbbill/undotree' " Navigating mistakes
" Syntax
Plug 'mxw/vim-jsx', { 'for': ['javascript', 'javascript.jsx', 'javascriptreact'] }
Plug 'pangloss/vim-javascript', { 'for': ['javascript', 'javascript.jsx', 'javascriptreact'] }
Plug 'neovimhaskell/haskell-vim', { 'for': 'haskell' }
Plug 'rust-lang/rust.vim', { 'for': 'rust' }
Plug 'aliva/vim-fish', { 'for': 'fish' }
" " Ruby
Plug 'AndrewRadev/splitjoin.vim', { 'for': 'ruby' }
Plug 'sunaku/vim-ruby-minitest', { 'for': 'ruby' }
Plug 'tpope/vim-bundler', { 'for': 'ruby' }
Plug 'tpope/vim-rails', { 'for': 'ruby' }
Plug 'tpope/vim-rake', { 'for': 'ruby' }
" Various utilities I need
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-surround'
" Various utilities I really like
Plug 'tpope/vim-eunuch' " For renaming files, making new directories, etc
Plug 'tpope/vim-rsi' " Things like C-a to go home, C-e to go end
" Various utilities
Plug 'tpope/vim-repeat'
Plug 'tpope/vim-dispatch'
Plug 'ConradIrwin/vim-bracketed-paste'
Plug 'janko-m/vim-test'
Plug 'mattn/emmet-vim', { 'for': ['eruby', 'html'] }
Plug 'tpope/vim-abolish' " I use it to convert snake case to camel case and stuff
Plug 'tpope/vim-endwise' " Add end to the end
Plug 'tpope/vim-fugitive' " Git integration
Plug 'tpope/vim-rhubarb' " GitHub integration
Plug 'tpope/vim-projectionist' " Jumping to alternate files with :A
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-sleuth' " Automatically set indentation
Plug 'tpope/vim-unimpaired' " Pairs of bracket maps
Plug 'stefandtw/quickfix-reflector.vim'
if filereadable(expand('~/.vim/vimrc_plugins_local'))
  source $HOME/.vim/vimrc_plugins_local
endif
call plug#end()

" load sensible configs early
runtime! plugin/sensible.vim
runtime! plugin/sleuth.vim

augroup custom_highlights
  autocmd!
  autocmd ColorScheme * highlight TabCharacters ctermfg=LightMagenta cterm=underline guifg=LightMagenta gui=underline
  autocmd BufWinEnter * let w:match_trailing_whitespace=matchadd('ErrorMsg', '\s\+$', -1)
  autocmd BufWinEnter * let w:match_tab_chars=matchadd('TabCharacters', '\t\+', -1)
augroup END

try
  colorscheme github
catch
  colorscheme default
endtry

augroup my_file_types
  autocmd!
  autocmd FileType gitcommit setlocal spell
  autocmd FileType gitcommit setlocal colorcolumn=72

  autocmd FileType haskell setlocal shiftwidth=2 tabstop=2 expandtab

  autocmd FileType markdown setlocal spell
  autocmd FileType markdown setlocal textwidth=80
  autocmd FileType markdown setlocal shiftwidth=2 tabstop=2 expandtab

  autocmd FileType ruby setlocal commentstring=#\ %s
  autocmd FileType ruby setlocal shiftwidth=2 tabstop=2 expandtab

  autocmd FileType eruby setlocal shiftwidth=2 tabstop=2 expandtab

  autocmd FileType qf set nobuflisted
  autocmd FileType qf setlocal nowrap

  autocmd BufNewFile,BufRead * if &filetype ==# '' | set filetype=noft | endif
  autocmd FileType noft setlocal shiftwidth=4 tabstop=4 expandtab

  autocmd BufNewFile,BufRead *.cr set syntax=ruby
  autocmd BufNewFile,BufRead *.cr setfiletype ruby

  autocmd BufNewFile,BufRead *.json.jb set filetype=ruby
augroup END

augroup let_me_switch_buffers_without_saving
  autocmd!
  autocmd BufEnter,BufWinEnter * set hidden
augroup END

if (exists('+colorcolumn'))
  set colorcolumn=80 " show ruler on startup
  highlight ColorColumn ctermbg=LightMagenta

  augroup show_ruler_only_in_active_window
    autocmd!
    autocmd WinEnter * set colorcolumn=80
    autocmd WinLeave * set colorcolumn=0
  augroup END
endif

augroup auto_exit_insert_caps
  autocmd!
  autocmd BufEnter,BufWinEnter * set iminsert=0
  autocmd InsertLeave * set iminsert=0
augroup END

command! -bang FuzzySilver call fzf#run(fzf#wrap('ag-fzf', { 'options': '--multi', 'source': 'ag --files-with-matches --filename-pattern "" --ignore "\.git$\|\.hg$\|\.svn$" --skip-vcs-ignores' }, <bang>0))
command! Gjedi Dispatch git jedi
command! Vsplit botright vsplit
command! Split botright split
command! Vs Vsplit
command! Sp Split
command! Wq x
command! Wqa xa
command! Qa qa
command! -nargs=1 Read 0read ~/.vim/templates/<args> | %substitute#\[:VIM_EVAL:\]\(.\{-\}\)\[:END_EVAL:\]#\=eval(submatch(1))#ge
command! -nargs=* Figlet call FigletFigletTrioTrioTrio(<q-args>)

set commentstring=#\ %s
set number
set splitbelow " create buffer at the bottom of active buffer
set splitright " create buffer at the right of active buffer
set wildmode=longest,list,full
set linebreak
set scrolloff=3
set hlsearch
set nofoldenable
set ignorecase " Ignorecase and smartcase work together
set smartcase
set cmdheight=2
set shellpipe=2>&1\|\ tee\ 
set imsearch=-1
set keymap=insert_caps
set nojoinspaces

let g:markdown_fenced_languages = ['html', 'ruby', 'bash=sh', 'sh']
let g:netrw_banner = 0
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
let g:netrw_bufsettings = 'nomodifiable nomodified number nobuflisted nowrap readonly'
let test#strategy = 'dispatch'
let g:fzf_command_prefix = 'Fzf'
let g:fzf_layout = { 'down': '~40%' }
let g:ackprg = 'ag --vimgrep'
let g:ack_use_dispatch = 1

let g:lightline = {
  \ 'colorscheme': 'Tomorrow',
  \ 'active': {
  \   'left': [
  \     [ 'mode', 'paste' ],
  \     [ 'fugitive', 'filename', 'modified' ]
  \   ]
  \ },
  \ 'component': {
  \   'fugitive': '%{exists("*fugitive#head")?fugitive#head():""}'
  \ },
  \ 'component_visible_condition': {
  \   'fugitive': '(exists("*fugitive#head") && ""!=fugitive#head())'
  \ },
\ }

let g:fzf_colors = {
  \ 'fg':      ['fg', 'Normal'],
  \ 'bg':      ['bg', 'Normal'],
  \ 'hl':      ['fg', 'Comment'],
  \ 'fg+':     ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
  \ 'bg+':     ['bg', 'CursorLine', 'CursorColumn'],
  \ 'hl+':     ['fg', 'Statement'],
  \ 'info':    ['fg', 'PreProc'],
  \ 'prompt':  ['fg', 'Conditional'],
  \ 'pointer': ['fg', 'Exception'],
  \ 'marker':  ['fg', 'Keyword'],
  \ 'spinner': ['fg', 'Label'],
  \ 'header':  ['fg', 'Comment']
\ }

let g:rails_projections = {
  \  "app/controllers/*_controller.rb": {
  \      "test": [
  \        "spec/requests/{}_spec.rb",
  \        "spec/controllers/{}_controller_spec.rb",
  \        "test/controllers/{}_controller_test.rb"
  \      ],
  \      "alternate": [
  \        "spec/requests/{}_spec.rb",
  \        "spec/controllers/{}_controller_spec.rb",
  \        "test/controllers/{}_controller_test.rb"
  \      ],
  \   },
  \   "spec/requests/*_spec.rb": {
  \      "command": "request",
  \      "alternate": "app/controllers/{}_controller.rb",
  \      "template": [
  \        "require \"rails_helper\"",
  \        "",
  \        "RSpec.describe {camelcase|capitalize|colons}Controller, type: :request do",
  \        "end"
  \      ]
  \   },
\ }

function! FigletFigletTrioTrioTrio(cmd_args)
  let cmd = 'figlet ' . a:cmd_args
  " run the figlet command!
  let output = system(cmd)
  " remove the final newline
  let output = substitute(output, '\n$', '', '')
  " make each line start with a # (except the first)
  let output = substitute(output, '\n', '\n# ', 'g')
  " make the first line start with a #
  let output = substitute(output, '^', '# ', 'g')
  " remove trailing whitespace, on all lines except the last
  let output = substitute(output, '\s\+\n', '\n', 'g')
  " remove trailing whitespace on the last line, and add a trailing newline
  let output = substitute(output, '\s\+$', '\n', 'g')

  $put=output
endfunction

nnoremap - :<C-U>Explore<CR>
nnoremap <C-P> :<C-U>FuzzySilver<CR>

" Perform case-sensitive searches when searching with `*` or `#`
nnoremap * /\<<C-R>=expand('<cword>')<CR>\>\C<CR>
nnoremap # ?\<<C-R>=expand('<cword>')<CR>\>\C<CR>

" navigating and manipulating buffers, splits, tabs
nnoremap <TAB>   :bnext<CR>
nnoremap <S-TAB> :bprev<CR>
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>
nnoremap <C-H> <C-W><C-H>
nnoremap _ :FzfBuffer<CR>
nnoremap <Leader>te :tabe %<CR>
nnoremap <Leader>tq :tabc<CR>

" redraw and nohl (from vim-sensible)
nnoremap <silent> <Leader>l :nohlsearch<C-R>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-L>

noremap <Leader>y "*y

nnoremap <Leader><space> @q

" delete buffer without removing split
nnoremap <Leader>bd :b#<bar>bd#<CR>

nnoremap <Leader>tt :TestNearest<CR>
nnoremap <Leader>tf :TestFile<CR>
nnoremap <Leader>ts :TestSuite<CR>
nnoremap <Leader>tl :TestLast<CR>
nnoremap <Leader>tv :TestVisit<CR>

nnoremap <Leader>ve :tabe $MYVIMRC<CR>
nnoremap <Leader>vs :source $MYVIMRC<CR>

nnoremap <Leader>cc :sp<CR><C-]>
nnoremap <Leader>cv :vs<CR><C-]>

nnoremap <Leader>u :UndotreeToggle<CR>

inoremap jk <Esc>
inoremap Jk <Esc>

inoremap <CR> <C-G>u<CR>

vnoremap < <gv
vnoremap > >gv

nnoremap H <Nop>
nnoremap M <Nop>
nnoremap L <Nop>
nnoremap K <Nop>
vnoremap K <Nop>

nnoremap <Del> l

iabbrev Javascript JavaScript

vnoremap <Leader>d64 c<c-r>=system('base64 --decode', @")<cr><esc>
vnoremap <Leader>e64 c<c-r>=system('base64', @")<cr><esc>

if filereadable(expand('~/.vim/vimrc_local'))
  source $HOME/.vim/vimrc_local
endif
